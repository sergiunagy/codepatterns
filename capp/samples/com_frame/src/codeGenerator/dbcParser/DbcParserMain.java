/**
 * @file DbcParserMain.java
 * Main function of DBC parser; a wrapper around the code generated by antlr4 from the
 * grammar.
 *
 * Copyright (C) 2015-2018 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Interface of class DbcParserMain
 *   DbcParserMain
 *   parse
 */

package codeGenerator.dbcParser;

import java.util.*;
import java.io.*;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.apache.log4j.*;

public class DbcParserMain
{
    /** Access the Apache logger object. */
    private static Logger _logger = Logger.getLogger(DbcParserMain.class.getName());
    
    /** An error listener for the parsing process. This listener integrates the parser
        in our application by redirecting the antlr output into our logging. */
    private ParseErrorListener parseErrListener_ = null;

    /** The lexer that knows our grammar. */
    private DbcLexer lexer_ = null;

    /** The last recent parse result can be found here. */
    private ParseTree parseTree_ = null;


    /**
     * Create a new parser wrapper.
     *   This parser can be reused for multiple files to be parsed. Just re-run its main
     * method #parse.
     */
    public DbcParserMain()
    {
        /* Get an error listener for the parsing process. This listener integrates the parser
           in our application by redirecting the antlr output into our logging. */
        parseErrListener_ = new ParseErrorListener(/* errCnt */ null);

        /* Create a lexer that knows our grammar. */
        lexer_ = new DbcLexer(null);

        /* Install listener for error reporting. */
        lexer_.removeErrorListeners();
        lexer_.addErrorListener(parseErrListener_);

    } /* End of DbcParserMain */



    /**
     * Parse a DBC file.
     *   Use this method to run the parser on a single DBC file.
     *   @return
     * Get the parse tree if parsing ends without errors or null otherwise.
     *   @param dbcFileName
     * The name of the file to be parsed.
     *   @param errCnt
     * A specific error counter object to be used for this parse. It is not reset, several
     * files can be parsed with continuous counting.
     */
    public ParseTree parse(String dbcFileName, ErrorCounter errCnt)
    {
        /* Use the passed error counter during parsing. */
        parseErrListener_.setErrorCounter(errCnt);
        
        try
        {
            /* Create a CharStream that reads from the specified input file. */
            ANTLRInputStream input = new ANTLRFileStream(dbcFileName);

            /* Feed input stream to the lexer and reset it for parsing next file. */
            lexer_.setInputStream(input);

            /* Create a buffer of tokens pulled from the lexer. */
            CommonTokenStream tokens = new CommonTokenStream(lexer_);

            /* Create a parser that feeds off the tokens buffer. */
            DbcParser parser = new DbcParser(tokens);

            /* Install same listener for error reporting as for lexer. */
            parser.removeErrorListeners();
            parser.addErrorListener(parseErrListener_);

            /* Parse according to main grammar rule dbc. */
            parseTree_ = parser.dbc();

            /* Log parse tree in Lisp style in Debug verbosity. */
//            if(_logger.isDebugEnabled())
//                _logger.debug(parseTree_.toStringTree(parser));

            /* Create a standard walker for semantik tests. */
            ParseTreeWalker walker = new ParseTreeWalker();

            /* Do the walk with the checker-walker to find syntactic problems not found
               during grammar matching. */
            SemanticCheckListener semanticCheckListener = new SemanticCheckListener(errCnt);
            walker.walk(semanticCheckListener, parseTree_);
        }
        catch(java.io.FileNotFoundException e)
        {
            errCnt.error();
            _logger.error("Input file not found. " + e.getMessage());
        }
        catch(java.io.IOException e)
        {
            errCnt.error();
            _logger.error("Error reading input file. " + e.getMessage());
        }
        catch(Exception e)
        {
            /* If we ever get here it has to be considered an implementation error. This is
               a not anticipated error. This might be due to a true bug or because of
               insufficient error handling code. */
            assert false: "Unexpected exception. It's either a bug or bad error handling code";

            /* If not being in devlopment mode we can try to make the feedback to the user
               somewhat more convenient then an uncaught error at the application root
               function .*/
            errCnt.error();
            StringBuffer sbStackTrace = new StringBuffer("Call stack:\n");
            for(StackTraceElement stackTraceElem: e.getStackTrace())
            {
                sbStackTrace.append(stackTraceElem.toString());
                sbStackTrace.append("\n");
            }
            _logger.error("Uncaught error during parsing."
                          + (e.getMessage() != null? " " + e.getMessage(): "")
                          + " Please look carefully at the call stack; maybe it gives" 
                          + " an indication where the problem results from:\n"
                          + sbStackTrace
                         );
        }
        
        ParseTree parseTree = errCnt.getNoErrors() == 0? parseTree_: null;
        
        /* This parser must not take permanent ownership of the error counter. */
        parseErrListener_.setErrorCounter(/* errCnt */ null);
        
        return parseTree;
        
    } /* End of DbcParserMain.parse */
    
    
    
    /**
     * Parse a DBC file.
     *   Use this method to run the parser on a single DBC file.
     *   @return
     * Get the parse tree if parsing ends without errors or null otherwise.
     *   @param dbcFileName
     * The name of the file to be parsed.
     */
    public ParseTree parse(String dbcFileName)
    {
        /* A new file is parsed: Get a new, reset global error/warnings counter
           variable. */
        ErrorCounter errCnt = new ErrorCounter();
        ParseTree parseTree = parse(dbcFileName, errCnt);

        /* No specific error counter should be used, continued counting seems not an issue
           and nor is the counter visible from outside so we should summarize this
           parsing process now. */
        _logger.info("Parsing done with " + errCnt.getNoErrors() + " errors and "
                     + errCnt.getNoWarnings() + " warnings"
                    );
        
        return parseTree;

    } /* End of DbcParserMain.parse */
    
} /* End of class DbcParserMain */

